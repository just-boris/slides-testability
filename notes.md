# Allure
Я разрабатываю интерфейс для просмотра отчетов о результатах тестов. Это single-page application, в котором есть много разных динамических списков, таблиц с сортировкой и диаграмм - это довольно большой объем кода. Приложение построено на Angular.js с применением дополнительных библиотек (angular-ui, d3.js). Поскольку оно предназначено для тестировщиков, то должно быть идеально протестировано, но при этом специальных тестировщиков ему не полагается, поэтому весь контроль качества выполняется разработчками, то есть мной. Разумеется, возникла идея автоматизировать этот процесс. И сейчас приложение автоматически прогоняет тесты на jasmine перед каждым обновлением master-ветки, поэтому я могу быть увернен в том что у пользователей все работает как надо без бесконечных проверок вручную.

И сейчас я расскажу как мы к этому шли и какие трудности преодолевали. А начну с определения теста.
# Что такое тесты
Автотесты - это автоматическое выполнение проверок результатов работы какого-то кода. Допустим, это наше приложение. Мы можем написать проверки и следить за их успешностью. Если в коде что-то сломается, то тесты это сразу же продемонстрируют.

# Подготовка кода
## Полохой код
Чтобы все так и было, нужен качественный код.
Самая большой недостаток приложений без тестов - они монолитные. Это логично, потому что одному разработчику гораздо проще работать с единым куском кода. Лучше, если js-код пишут несколько специалистов, тогда появляются какие-то компоненты, но все равно очень часто код выглядит вот так: `1-1-3-2-bad-example.md`. Соответственно и тест такого кода будет выглядить соответсвтвующе.
## Делим на блоки
И первое что нужно сделать, это упросить его и разбить на отдельные блоки и описать как каждый блок взаимодействует с другими. Это позволит исключить различного рода магию, и понять что этому блоку требуется от других и что он сам предоставляет остальным. При этом отдельный блок тестировать проще, чем их связку, поскольку это позволяет не держать в уме сразу много информации. `1-1-3-5-declare-interaction.md` Например, если бы мы тестировали эти два блока вместе, то чтобы добраться до второго блока, нам пришлось бы постоянно вызывать что-то в первом вместо того чтобы сразу напрямую обратиться к нужному.
## Заглушки (моки)
Поэтому мы изолируем каждый блок и тестируем его в отдельной тестовой среде. Вместо других модулей мы ему подставляем заглушки. Это имитация модуля, которая выглядит точно также, но не содержит внутренней логики и всего лишь контролирует правильность обращения с ней. В jasmine такие заглушки делаются очень легко, поэтому пользоваться ими - одно удовольствие.

# Написание тестов

Когда код получился хорошим и тестопригодным, это уже хорошо, потому что его качество и читаемость возросли. Но чтобы извлечь еще больше пользы из такого подхода, пора начинать писать тесты.
Код тестов должен быть коротким и ясным, чтобы сразу было понятно что именно он тестирует и какой результат он ждет. Иногда в тестах повторяются определенные действия, их нужно выносить в переиспользуемые функции.

Основная стратегия при написании тестов - много мелких проверок на разные части функционала. Это позволит по результатам тестов просто, практически русским языком, понять что именно сломалось, а при последующей разработке можно просто удалять тесты на вещи, которых больше нет и писать тесты на новые функции.

Чтобы так и получилось тесты должны быть независимыми. В том числе они не должны зависеть от того, в каком порядке их выполняют.

Для упрощения написания множества однотипных проверок можно использовать параметризованные тесты. Это означает что мы один раз описываем тестовый сценарий, а потом запускаем его со множеством тестовых данных. Циклы очень часто используется в программировании, но почему то при написании тестов об их существовании забывают, и совершенно зря.

#Результат

Что мы получили после окончательного внедрения unit-тестов? Во-первых большинство ошибок стали находиться автоматически и в результате вручную приходилось искать только самые нетривиальные.
Мы стали использовать tdd - принцип, когда сначала пишутся тесты, а потом под них подгоняется код программы. Благодаря этому мы смогли безопасно рефакторить наш код намного быстрее, потому что функционал был под контролем автотестов.

Ну и наконец я смог проверить и некоторые непростые случаи использования, причем очень легко. Например, у нас есть специальная функция формата времени. При ручном тестировании трудно проверить все возможные значения, потому что не всегда данные так просто генерировать. Зато а unit-тесте можно проверить форматирование любого случая - достаточно ввести нужное значение и проверить результат.